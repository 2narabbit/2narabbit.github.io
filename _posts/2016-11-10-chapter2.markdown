---
layout: default
title:  "2장 - 테스트"
date:   2016-11-10 00:00:00
categories: main
---

어플리케이션은 계속 변하고 복잡해져 간다. 그 변화에 대응하는 첫 번째 전략이 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술이라면, 두 번째 전략은 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 테스트 기술이다.

# UserDaoTest 다시 보기

## 테스트의 유용성
이전에 만들었던 테스트 코드는 main() 메소드를 이용해 UserDao 오브젝트의 add(), get() 메소드를 호출하고, 그 결과를 화면에 출력해서 그 값을 눈으로 확인시켜준다. 이렇게 만든 테스트용 main() 메소드를 반복적으로 실행해가면서 처음 설계한 대로 기능이 동작하는지를 매 단계 확인한 덕분에, 다양한 방법으로 초난감 UserDao 코드의 설계와 코드를 개선했고, 심지어 스프링을 적용해서 동작하게 만들 수도 있었다.

테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다. 또한 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다. 이를 통해 코드의 결함을 제거해가는 작업, 일명 디버깅을 거치게 되고, 결국 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다.

## UserDaoTest의 특징

### 웹을 통한 DAO 테스트 방법의 문제점
보통 웹 프로그램에서 사용하는 DAO를 테스트하는 방밥은 다음과 같다. DAO를 만든 뒤 바로 테스트하지 않고, 서비스 계층, MVC 프레젠테이션 계층까지 포함한 모든 입출력 기능을 대충이라도 코드로 다 만든다. 이렇게 만들어진 테스트용 웹 어플리케이션을 서버에 배치한 뒤 웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인한다. 이 방법은 가장 흔히 쓰이는 방법이지만, DAO에 대한 테스트로서는 단점이 너무 많다.

일단 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다는 것이 가장 큰 문제다. 또한 테스트를 하는 중에 에러가 나거나 테스트가 실패했다면, 과연 어디에서 문제가 발생했는지를 찾아내야 하는 수고도 필요하다. 하나의 테스트를 수행하는 데 참여하는 클래스와 코드가 너무 많기 때문이다. 테스트하고 싶었던 건 UserDao였는데 다른 계층의 코드와 컴포넌트, 심지어 서버의 설정 상태까지 모두 테스트에 영향을 줄 수 있기 때문에 이런 방식으로 테스트하는 것은 번거롭고, 오류가 있을 때 빠르고 정확하게 대응하기가 힘들다는 문제가 있다.

### 작은 단위의 테스트
테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다. 한꺼번에 너무 많은 것을 몰아서 테스트하면 테스트 수행 과정도 복잡해지고, 오류가 발생했을 때 정확한 원인을 찾기가 힘들어진다.

UserDaoTest는 한 가지 관심에 집중할 수 있게 작은 단위로 만들어진 테스트다. 이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 **단위 테스트**라고 한다. 일반적으로 단위는 작을수록 좋다. 단위를 넘어서는 다른 코드들은 신경 쓰지 않고, 참여하지도 않고 테스트가 동작할 수 있으면 좋다.

때로는 웹 사용자 인터페이스부터 시작해서 DB에 이르기까지의 어플리케이션 전 계층이 참여하고, 각종 기능을 모두 사용하는 전 과정을 하나로 묶어서 테스트할 필요도 있다. 아마도 수많은 에러를 만나거나 에러는 안 나지만 제대로 기능이 동작하지 않는 경험을 하게 될 것이다. 이때는 문제의 원인을 찾기가 매우 힘들다. 예외가 발생해도 그 이유를 찾는 데 많은 시간이 걸릴 수 있다. 그런데 각 단위별로 테스트를 먼저 모두 진행하고 나서 이런 긴 테스트를 시작했다면 어떨까? 그래도 역시 예외가 발생하거나 테스트가 실패할 수는 있겠지만, 이미 각 단위별로 충분한 검증을 마치고 오류를 잡았으므로 훨씬 나을 것이다.

### 자동수행 테스트 코드
테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다. 테스트 자체가 사람의 수작업을 거치는 방법을 사용하기보다는 코드로 만들어져서 자동으로 수행될 수 있어야 한다는 건 매우 중요하다.

자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것이다. 번거로운 작업이 없고 테스트를 빠르게 실행할 수 있기 때문에 언제든 코드를 수정하고 나서 테스트를 해볼 수 있다.

### 지속적인 개선과 점진적인 개발을 위한 테스트
처음 만든 초난감 DAO 코드를, 스프링을 이용한 깔끔하고 완성도 높은 객체지향적 코드로 발전시키는 과정의 일등 공신은 바로 이 테스트였다. 테스트가 없었다면, 다양한 방법을 동원해서 코드를 수정하고 설계를 개선해나가는 과정이 그다지 미덥지 않을 수도 있고, 그래서 마음이 불편해지면 이쯤에서 그만두자는 생각이 들 수도 있었기 때문이다.

하지만 일단은 단순 무식한 방법으로 정상동작하는 코드를 만들고, 테스트를 만들어뒀기 때문에 매우 작은 단계를 거쳐가면서 계속 코드를 개선해나갈 수 있었다. 오히려 그렇게 작은 단계를 거치는 동안 테스트를 수행해서 확신을 가지고 코드를 변경해갔기 때문에 전체적으로 코드를 개선하는 작업에 속도가 붙고 더 쉬워졌을 수도 있다.

## UserDaoTest의 문제점
UserDaoTest가 UI까지 동원되는 번거로운 수동 테스트에 비해 장점이 많은 건 사실이다. 하지만 만족스럽지 못한 부분도 있다.

* 수동 확인 작업의 번거로움
    * add()에서 User 정보를 DB에 등록하고, 이를 다시 get()을 이용해 가져왔을 때 입력한 값과 가져온 값이 일치하는지를 테스트 코드는 확인해주지 않는다. 단지 콘솔에 값만 출력해줄 뿐이다.
	* 결국 그 콘솔에 나온 값을 보고 등록과 조회가 성공적으로 되고 있는지를 확인하는 건 사람의 책임이다.
* 실행 작업의 번거로움
    * 만약 DAO가 수백 개가 되고 그에 대한 main() 메소드도 그만큼 만들어진다면, 전체 기능을 테스트해보기 위해 main() 메소드를 수백 번 실행하는 수고가 필요하다.

이 두 가지 문제점을 개선해보자.

# UserDaoTest 개선

## 테스트 검증의 자동화
먼저 테스트 결과의 검증 부분을 코드로 만들어보자.

모든 테스트는 성공과 실패의 두 가지 결과를 가질 수 있다. 또 테스트의 실패는 테스트가 진행되는 동안에 에러가 발생해서 실패하는 경우와, 테스트 작업 중에 에러가 발생하진 않았지만 그 결과가 기대한 것과 다르게 나오는 경우로 구분해볼 수 있다. 여기서 전자를 테스트 에러, 후자를 테스트 실패로 구분해서 부르겠다.

테스트 중에 에러가 발생하는 것은 쉽게 확인이 가능하다. 콘솔에 에러 메시지와 긴 호출 스택 정보가 출력되기 때문이다. 하지만 테스트가 실패하는 것은 별도의 확인 작업과 그 결과가 있어야만 알 수 있다.

그러고보면 기존에 출력했던 "조회 성공"이라는 메세지는 사실 get() 메소드가 에러없이 끝났다는 의미이지 조회 테스트가 모두 성공했다는 뜻은 아니었다.

```
// 수정 전 테스트 코드
System.out.println(user2.getName());
System.out.println(user2.getPassword());
System.out.println(user2.getId() + "조회 성공");

// 수정 후 테스트 코드
if (!user.getName().equals(user2.getName())) {
	System.out.println("테스트 실패 (name)");
}
else if (!user.getPassword().equals(user2.getPassword())) {
	System.out.println("테스트 실패 (password)");
}
else {
	System.out.println("조회 테스트 성공");
}
```

이렇게 해서 테스트의 수행과 테스트 값 적용, 그리고 결과를 검증하는 것까지 모두 자동화했다. 이제 거의 모든 과정을 자동화한 테스트가 만들어졌다. 테스트를 수행하고 나서 할 일은 마지막 출력 메세지가 "테스트 성공"이라고 나오는지 확인하는 것 뿐이다.

> 자동화된 테스트를 위한 xUnit 프레임워크 개발자 켄트 백은 **테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것**이라고 했다.

## 테스트의 효율적인 수행과 결과 관리
이제 main() 메소드로 만든 테스트는 테스트로서 필요한 기능은 모두 갖춘 셈이다. 하지만 좀 더 편리하게 테스트를 수행하고 편리하게 결과를 확인하려면 단순한 main() 메소드로는 한계가 있다.

이미 자바에는 단순하면서도 실용적인 테스트를 위한 도구가 여러 가지 존재한다. 그 중에서도 프로그래머를 위한 자바 테스팅 프레임워크라고 불리는 JUnit은 유명한 테스트 지원 도구다. 지금까지 만들었던 main() 메소드 테스트를 JUnit을 이용해 다시 작성해보자.

### 테스트 메소드 전환
가장 먼저 할 일은 main() 메소드에 있던 테스트 코드를 일반 메소드로 옮기는 것이다. 새로 만들 테스트 메소드는 JUnit 프레임워크가 요구하는 조건 두 가지를 따라야 한다. 첫째는 메소드가 public으로 선언되야 하는 것이고, 다른 하나는 메소드에 @Test라는 애노테이션을 붙여주는 것이다.

```
public class UserDaoTest() {
	@Test
	public void addAndGet() throws SQLException {
		ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

		UserDao dao = context.getBean("userDao", UserDao.class);
		....
	}
}
```

### 검증 코드 전환
다음 if 문은 처음 add()에 사용했던 user 오브젝트의 name 값과 get()에서 가져온 user2 오브젝트의 name 값이 같으면 다음으로 넘어가고, 아니면 테스트가 실패하게 한다. 이 if 문장의 기능을 JUnit이 제공해주는 assertThat이라는 스태틱 메소드를 이용해 변경할 수 있다.

```
if (!user.getName().equals(user2.getName())) {
	...
}

--> assertThat(user2.getName(), is(user.getName()));
```

assertThat()은 첫 번째 파라미터의 값을 뒤에 나오는 매처라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다. is()는 매처의 일종으로 equals()로 비교해주는 기능을 가졌다.

JUnit은 예외가 발생하거나 assertThat()에서 실패하지 않고 테스트 메소드의 실행이 완료되면 테스트가 성공했다고 인식한다. "테스트 성공"이라는 메세지를 굳이 출력할 필요가 없다.

```
public class UserDaoTest() {
	@Test
	public void addAndGet() throws SQLException {
		ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

		UserDao dao = context.getBean("userDao", UserDao.class);
		User user = new User();
		user.setId("gyumee");
		user.setName("박성철");
		user.setPassword("springno1");

		dao.add(user);

		User user2 = dao.get(uesr.getId());

		assertThat(user2.getName(), is(user.getName()));
		assertThat(user2.getPassword(), is(user.getPassword()));
	}
}
```

### JUnit 테스트 실행
JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 한 번은 JUnit 프레임워크를 시작시켜 줘야 한다. 어디에든 main() 메소드를 하나 추가하고, 그 안에 JUnitCore 클래스의 main 메소드를 호출해주는 간단한 코드를 넣어주면 된다. 메소드 파라미터에는 @Test 테스트 메소드를 가진 클래스의 이름을 넣어준다.

```
public static void main(String[] args) {
	JUnitCore.main("springbook.user.dao.UserDaoTest");
}
```

이 클래스를 실행하면 테스트를 실행하는 데 걸린 시간과 테스트 결과, 그리고 몇 개의 테스트 메소드가 실행됐는지를 알려준다.

# 개발자를 위한 테스팅 프레임워크 JUnit
JUnit은 사실상 자바의 표준 테스팅 프레임워크라고 불릴 만큼 폭넓게 사용되고 있다. 스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다. 

## JUnit 테스트 실행 방법
*IDE와 빌드툴(앤트, 메이븐)을 이용하여 테스트를 실행하는 방법을 기술하므로 생략*

## 테스트 결과의 일관성
지금까지 테스트를 실행하면서 가장 불편했던 일은, 매번 UserDaoTest 테스트를 실행하기 전에 DB의 USER 테이블 데이터를 모두 삭제해줘야 할 때였다. 깜빡 잊고 그냥 테스트를 실행했다가는 이전 테스트를 실행했을 때 등록됐던 사용자 정보와 기본키가 중복된다면서 add() 메소드 실행 중에 에러가 발생할 것이다.

여기서 생각해볼 문제는 테스트가 외부 상태에 따라 성공하기도 하고 실패하기도 한다는 점이다. 이는 좋은 테스트라고 할 수가 없다. 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.

### deleteAll()과 getCount() 추가
일관성 있는 결과를 보장하는 테스트를 만들기 위해 UserDao에 새로운 기능을 추가해보자.

**deleteAll()**

첫 번째 추가할 것은 USER 테이블의 모든 레코드를 삭제해주는 deleteAll() 메소드이다.

```
public void deleteAll() throws SQLException {
	Connection c = dataSource.getConnection();

	PreparedStatement ps = c.prepareStatement("delete from users");
	ps.executeUpdate();

	ps.close();
	c.close();
}
```

**getCount()**

두 번째 추가할 것은 USER 테이블의 레코드 개수를 돌려주는 getCount() 메소드다.

```
public int getCount() throws SQLException {
	Connection c = dataSource.getConnection();

	PreparedStatement ps = c.prepareStatement("select count(*) from users");

	ResultSet rs = ps.executeQuery();
	rs.next();
	int count = rs.getInt(1);

	rs.close();
	ps.close();
	c.close();

	return count;
}
```

### deleteAll()과 getCount()의 테스트
기존의 addAndGet() 테스트의 불편한 점은 실행 전에 수동으로 USER 테이블의 내용을 모두 삭제해줘야 하는 것이었다. deleteAll()을 이용하면 테이블의 모든 내용을 삭제할 수 있으니 이 메소드를 테스트가 시작될 때 실행해주자.

deleteAll()을 넣는 것만으로는 조금 부족하다. deleteAll() 자체도 아직 검증이 안 됐는데 무턱대고 다른 테스트에 적용할 수는 없다. 그래서 getCount()를 함께 적용해보자. deleteAll()이 기대한 대로 동작한다면, getCount()로 레코드의 개수를 가져올 경우 0이 나와야 한다.

```
public class UserDaoTest() {
	@Test
	public void addAndGet() throws SQLException {
		ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

		UserDao dao = context.getBean("userDao", UserDao.class);

		dao.deleteAll();
		assertThat(dao.getCount(), is(0));

		User user = new User();
		user.setId("gyumee");
		user.setName("박성철");
		user.setPassword("springno1");

		dao.add(user);
		assertThat(dao.getCount(), is(1));

		User user2 = dao.get(uesr.getId());

		assertThat(user2.getName(), is(user.getName()));
		assertThat(user2.getPassword(), is(user.getPassword()));
	}
}
```

### 동일한 결과를 보장하는 테스트
단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다는 점을 잊어선 안된다. DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.

# 스프링 테스트 적용

# 학습 테스트로 배우는 스프링
