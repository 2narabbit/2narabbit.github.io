<!DOCTYPE html>
<html lang="en-us">
  
  <head>
  <meta charset="UTF-8">
  <title>Spring Framework Study</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/cayman.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">Spring Framework Study</h1>
  <h2 class="project-tagline">To be a web developer. go for it!</h2>
</section>


    <section class="main-content">
      
      <p>스프링이 가장 관심을 많이 두는 대상은 <strong>오브젝트</strong>다. 스프링을 이해하려면 먼저 오브젝트에 깊은 관심을 가져야 한다.
1장에서는 스프링이 어떤 것이고, 무엇을 제공하는지보다는 스프링이 관심을 갖는 대상인 오브젝트의 설계와 구현, 동작원리에 더 집중하자.</p>

<h1 id="dao">초난감 DAO</h1>
<p>사용자 정보를 JDBC API를 통해 DB에 저장하고 조회할 수 있는 간단한 DAO를 하나 구현해보자.</p>

<h2 id="user">User</h2>
<p>사용자 정보를 저장하기위해 자바빈 규약을 따르는 클래스를 선언하자.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class User {
	String id;
	String name;
	String password;

	public String getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public String getPassword() {
		return password;
	}

	public void setId(String id) {
		this.id = id;
	}

	public void setName(String name) {
		this.name = name;
	}

	public void setPassword(String password) {
		this.password = password;
	}
}
</code></pre>
</div>

<blockquote>
  <p><strong>자바빈?</strong></p>

  <p>다음 두가지 관례를 따라 만들어진 오브젝트를 의미하며 간단히 빈이라고 부르기도함</p>

  <ul>
    <li>디폴트 생성자
      <ul>
        <li>자바빈은 파라미터가 없는 디폴트 생성자를 가져야함</li>
        <li>툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문 —&gt; 리플렉션?</li>
      </ul>
    </li>
    <li>프로퍼티
      <ul>
        <li>자바빈이 노출하는 이름을 가진 속성을 의미</li>
        <li>프로퍼티는 set으로 시작하는 수정자 메소드(setter)와 get으로 시작하는 접근자 메소드(getter)를 이용해 수정 또는 조회 가능</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="userdao">UserDao</h2>
<p>사용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스를 만들어보자.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class UserDao {
	public void add(User user) throws ClassNotFoundException, SQLException {
		// DB 연결을 위한 Connection을 가져온다.
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/test", "mysql", null);

		// SQL을 담은 statement를 만든다.
		PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");
		ps.setString(1, user.getId());
		ps.setString(2, user.getName());
		ps.setString(3, user.getPassword());

		// statement를 실행한다.
		ps.executeUpdate();

		// 작업을 마친 뒤 리소스를 정리한다.
		ps.close();
		c.close();
	}

	public User get(String id) throws ClassNotFoundException, SQLException {
		// DB 연결을 위한 Connection을 가져온다.
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/test", "mysql", null);

		// SQL을 담은 statement를 만든다.
		PreparedStatement ps = c.prepareStatement("select * from users where id=?");
		ps.setString(1, id);

		// statement를 실행한다.
		ResultSet rs = ps.executeQuery();
		rs.next();

		// 쿼리 실행 결과를 받아서 오브젝트에 옮겨준다.
		User user = new User();
		user.setId(rs.getString("id"));
		user.setName(rs.getString("name"));
		user.setPassword(rs.getString("password"));

		// 작업을 마친 뒤 리소스를 정리한다.
		rs.close();
		ps.close();
		c.close();

		return user;
	}
}
</code></pre>
</div>

<h2 id="main--dao--">main()을 이용한 DAO 테스트 코드</h2>
<p>만들어진 코드의 기능을 검증하기 위해 테스트 코드를 작성하자.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public static void main(String[] args) throws ClassNotFoundException, SQLException {
	UserDao dao = new UserDao();

	User user = new User();
	user.setId("ellie");
	user.setName("스프링");
	user.setPassword("12345678");

	dao.add(user);
	System.out.println(user.getId() + " 등록 성공");

	User user2 = dao.get(user.getId());
	System.out.println(user2.getName());
	System.out.println(user2.getPassword());

	System.out.println(user2.getId() + " 조회 성공");
}
</code></pre>
</div>

<p>이렇게 해서 사용자 정보의 등록과 조회가 되는 초간단 DAO를 구현하였으나 이 코드는 여러가지 문제를 가진 <strong>초난감 DAO</strong> 코드임!</p>

<h1 id="dao-">DAO의 분리</h1>
<p>오브젝트에 대한 설계와 이를 구현한 코드는 계속 변한다. 소프트웨어 개발에서 끝이란 개념은 없다ㅠㅠ
그래서 개발자는 미래의 변화를 어떻게 대비할 것인가를 염두하여 객체를 설계하여야 한다. 가장 좋은 대책은 <strong>변화의 폭을 최소한으로 줄여주는 것</strong>이다. 어떻게 변경이 일어날 때 필요한 작업은 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까?</p>

<p><strong>모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어나는데, 문제는 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다는 것이다.</strong>
변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 한가지 관심이 한 군데에 집중되게 하자!</p>

<h2 id="section">커넥션 만들기의 추출</h2>
<p>UserDao의 구현된 메소드를 자세히 들여다보면 add() 메소드 하나에서만 적어도 세 가지 관심사항을 발견할 수 있다.</p>
<ol>
  <li>DB 연결을 위한 커넥션을 어떻게 가져올까</li>
  <li>SQL 문장을 담을 statement를 만들고 실행</li>
  <li>작업이 끝난 뒤 사용한 리소스 처리</li>
</ol>

<p>가장 먼저 커넥션을 가져오는 중복된 코드를 분리하자.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public void add(User user) throws ClassNotFoundException, SQLException {
	Connection c = getConnection();
	....
}

public User get(String id) throws ClassNotFoundException, SQLException {
	Connection c = getConnection();
	....
}

private Connection getConnection() throws ClassNotFoundException, SQLException {
	Class.forName("com.mysql.jdbc.Driver");
	Connection c = DriverManager.getConnection("jdbc:mysql://localhost/test", "mysql", null);
	return c;
}
</code></pre>
</div>

<p>추후 DB연결과 관련된 부분에 변경이 일어났을 경우, getConnection() 메소드 하나만 수정하면 된다. 관심의 종류에 따라 코드를 구분해놓았기 때문에 한 가지 관심에 대한 변경이 일어날 경우 그 관심이 집중되는 부분의 코드만 수정하면 된다.</p>

<h2 id="section-1">커넥션 만들기의 독립</h2>
<p>UserDao 소스코드를 제공하지 않고도 원하는 DB 커넥션 생성 방식을 적용해가면서 UserDao를 사용하게 할 수 있을까? ㅇㅇ UserDao 코드를 한 단계 더 분리하자.</p>

<p>기존에는 같은 클래스에 다른 메소드로 분리했던 DB 커넥션 연결이라는 관심을 이번에는 <strong>상속을 통해 서브클래스로 분리</strong>해보자.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public abstract class UserDao {
    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
		....
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
		....
    }

    // 구현 코드는 제거되고 추상 메소드로 바뀌었다.
    // 메소드의 구현은 서브클래스가 담당한다.
    public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
}
</code></pre>
</div>

<p>UserDao의 소스코드가 없어도 UserDao 클래스 상속을 통해 getConnection() 메소드를 원하는 방식으로 확장하여 UserDao의 기능을 사용할 수 있게 되었다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>pulic class NUserDao extends UserDao {
	// 상속을 통해 확장된 DB 커넥션 생성 메소드
	public Connection getConnection() throws ClassNotFoundException, SQLException {
		....
	}
}
</code></pre>
</div>

<p>클래스 계층구조를 통해 두 개의 관심이 독립적으로 분리되면서 변경 작업은 한층 용이해졌다. 이제는 UserDao의 코드는 한 줄도 수정할 필요 없이 DB연결 기능을 새롭게 정의한 클래스를 만들 수 있다. 이제 UserDao는 단순히 변경이 용이하다는 수준을 넘어서 <strong>손쉽게 확장된다</strong>라고 말할 수 있게 되었다.</p>

<p>이렇게 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 <strong>템플릿 메소드 패턴</strong>이라고 한다.</p>

<blockquote>
  <p><strong>템플릿 메소드 패턴?</strong></p>

  <p>상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법.
변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록함.</p>
</blockquote>

<p>그리고 UserDao의 서브클래스의 getConnection() 메소드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법이라고도 볼 수 있다. 이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 <strong>팩토리 메소드 패턴</strong>이라고 부르기도 한다.</p>

<blockquote>
  <p><strong>팩토리 메소드 패턴?</strong></p>

  <p>템플릿 메소드 패턴과 마찬가지로 상속을 통해 기능을 확장하게 하는 패턴.</p>

  <p>슈퍼클래스는 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용하는 방식으로 구현. 이렇게 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 <strong>팩토리 메소드</strong>라고 하고, 이 방식을 통해 오브젝트 생성 방법을 슈퍼클래스의 기본 코드에서 독립시키는 방법을 팩토리 메소드 패턴이라고 한다.</p>

  <p><strong>(주의)</strong></p>

  <p>자바에서는 오브젝트를 생성하는 기능을 가진 메소드를 일반적으로 <strong>팩토리 메소드</strong>라고 부름. 이 때 말하는 팩토리 메소드와 팩토리 메소드 패턴의 팩토리 메소드는 의미가 다르므로 혼동하지 말아야함.</p>
</blockquote>

<p>이렇게 템플릿 메소드 패턴 또는 팩토리 메소드 패턴으로 관심사항이 다른 코드를 분리해내고, 서로 독립적으로 변경 또는 확장할 수 있도록 만드는 것은 간단하면서도 매우 효과적인 방법이다. 하지만 이 방법은 <strong>상속을 사용했다는 단점</strong>이 있다. 상속 자체는 간단하고 사용하기도 편리하지만 많은 한계점이 있다.</p>

<ul>
  <li>자바는 클래스의 다중상속을 허용하지 않는다. 단지 커넥션 객체를 가져오는 방법을 분리하기 위해 상속구조로 만들어버리면, 후에 다른 목적으로 UserDao에 상속을 적용하기 힘들다.</li>
  <li>또 다른 문제는 상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다는 점이다. 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있다. 그래서 슈퍼클래스 내부의 변경이 있을 때 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.</li>
  <li>확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다는 것도 큰 단점이다. 만약 UserDao외에 DAO 클래스들이 계속 만들어진다면 그때는 상속을 통해서 만들어진 getConnection()의 구현 코드가 매 DAO 클래스마다 중복돼서 나타나는 심각한 문제가 발생할 것이다.</li>
</ul>

<h1 id="dao--1">DAO의 확장</h1>
<p>지금까지는 성격이 다른, 그래서 <em>다르게 변할 수 있는 관심사를 분리하는 작업</em>을 점진적으로 진행해왔다.</p>
<ul>
  <li>처음에는 독립된 메소드를 만들어 분리했고,</li>
  <li>다음에는 상하위 클래스로 분리했다.</li>
</ul>

<p>이번에는 아예 상속관계도 아닌 완전히 독립적인 클래스로 만들어보자.</p>

<h2 id="section-2">클래스의 분리</h2>
<p>방법은 간단하다. DB 커넥션과 관련된 부분을 서브클래스가 아니라, 아예 별도의 클래스에 담는다. 그리고 이렇게 만든 클래스를 UserDao가 이용하게 한다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// DB 커넥션 생성 기능을 독립시킨 클래스를 선언한다.
public class SimpleConnectionMaker {
	public Connection makeNewConnection() throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		return DriverManager.getConnection("jdbc:mysql://localhost/test", "mysql", null);
	}
}
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>public class UserDao {
    private SimpleConnectionMaker simpleConnectionMaker;

    // SimpleConnectionMaker 클래스의 오브젝트를 미리 만들어 두고, 각 메소드에서 사용한다.
    public UserDao() {
        simpleConnectionMaker = new SimpleConnectionMaker();
    }

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = simpleConnectionMaker.makeNewConnection();
		....
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = simpleConnectionMaker.makeNewConnection();
		....
    }
}
</code></pre>
</div>

<p>성격이 다른 코드를 화끈하게 분리하기는 잘한 것 같은데, 다른 문제가 발생했다. UserDao의 코드가 SimpleConnectionMaker라는 특정 클래스에 종속되어 있기 때문에 상속을 사용했을 때처럼 UserDao 코드의 수정 없이 DB 커넥션 생성 기능을 변경할 방법이 없다ㅠㅠ</p>

<p>이런 문제의 근본적인 원인은 UserDao가 바뀔 수 있는 정보, 즉 DB 커넥션을 가져오는 클래스에 대해 너무 많이 알고 있기 때문이다. 어떤 클래스가 쓰일지, 그 클래스에서 커넥션을 가져오는 메소드는 이름이 뭔지까지 일일이 알고 있어야 한다. 따라서 <strong>UserDao는 DB 커넥션을 가져오는 구체적인 방법에 종속</strong>되어 버린다.</p>

<h2 id="section-3">인터페이스의 도입</h2>
<p>클래스를 분리하면서도 이런 문제를 해결할 수는 없을까? ㅇㅇ 가장 좋은 해결책은 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어주는 것이다. 추상화란 어떤 것들의 공통적인 성격을 뽑아내어 분리해내는 작업이다. 자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 인터페이스다.</p>

<p>인터페이스는 자신을 구현한 클래스에 대한 구체적인 정보는 모두 감춰버린다. 결국 오브젝트를 만들려면 구체적인 클래스 하나를 선택해야겠지만 인터페이스로 추상화해놓은 최소한의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들때 사용할 클래스가 무엇인지 몰라도 된다. <strong>인터페이스를 통해 접근하게 하면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다.</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>// UserDao가 사용할 인터페이스
public interface ConnectionMaker {
	public Connection makeConnection() throws ClassNotFoundException, SQLException;
}

// 인터페이스 구현체
public class DConnectionMaker implements ConnectionMaker {
	public Connection makeConnection() throws ClassNotFoundException, SQLException {
		// 원하는 방법으로 Connection을 생성하는 코드
	}
	....
}
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>public class UserDao {
	// 인터페이스를 통해 오브젝트에 접근하므로 구체적인 클래스 정보를 알 필요가 없다.
	private ConnectionMaker connectionMaker;

	public UserDao() {
		// 앗! 그런데 여기에는 클래스 이름이 나오네!!
		connectionMaker = new DConnectionMaker();
	}

	public void add(User user) throws ClassNotFoundException, SQLException {
		// 인터페이스에 정의된 메소드를 사용하므로 클래스가 바뀐다고 해도 메소드 이름이 변경될 걱정은 없다.
		Connection c = connectionMaker.makeConnection();
	}

	public User get(String id) throws ClassNotFoundException, SQLException {
		// 인터페이스에 정의된 메소드를 사용하므로 클래스가 바뀐다고 해도 메소드 이름이 변경될 걱정은 없다.
		Connection c = connectionMaker.makeConnection();
	}
}
</code></pre>
</div>

<p>UserDao의 다른 모든 곳에서는 인터페이스를 이용하게 만들어서 DB커넥션을 제공하는 클래스에 대한 구체적인 정보는 모두 제거가 가능했지만, 초기에 한 번 어떤 클래스의 오브젝트를 사용할지를 결정하는 생성자 코드는 제거되지 않고 남아있다.</p>

<h2 id="section-4">관계설정 책임의 분리</h2>
<p>두 개의 관심을 인터페이스를 써가면서까지 거의 완벽하게 분리했는데도 왜 문제가 발생하는 것일까? 그 이유는 UserDao 안에 <strong>분리되지 않은 또 다른 관심사항이 존재</strong>하고 있기 때문이다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>connectionMaker = new DConnectionMaker();
</code></pre>
</div>

<p>이 코드는 매우 짧고 간단하지만 그 자체로 충분히 독립적인 관심사를 담고 있다. 바로 UserDao가 어떤 ConnectionMaker 구현 클래스의 오브젝트를 이용하게 할지를 결정하는 것이다. 간단히 말하자면 <strong>UserDao와 UserDao가 사용할 ConnectionMaker의 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심</strong>이다.</p>

<p>UserDao를 사용하는 클라이언트가 적어도 하나는 존재할 것이다. 두 개의 오브젝트가 있고 한 오브젝트가 다른 오브젝트의 기능을 사용한다면, 사용되는 쪽이 사용하는 쪽에게 서비스를 제공하는 셈이다. 따라서 <strong>사용되는 오브젝트를 서비스, 사용하는 오브젝트를 클라이언트</strong>라고 부를 수 있다. UserDao의 클라이언트라고 하면 UserDao를 사용하는 오브젝트를 가리킨다. 이 UserDao의 클라이언트 오브젝트가 바로 제 3의 관심사항인 UserDao와 ConnectionMaker 구현 클래스의 관계를 결정해주는 기능을 분리해서 두기에 적절한 곳이다.</p>

<p>클라이언트는 자기가 UserDao를 사용해야 할 입장이기 때문에 UserDao의 세부 전략이라고도 볼 수 있는 ConnectionMaker의 구현 클래스를 선택하고, 선택한 클래스의 오브젝트를 생성해서 UserDao와 연결해줄 수 있다. 기존의 UserDao에서는 생성자에게 이 책임이 있었다. 자, 이제 이 관심을 분리해서 클라이언트에게 떠넘겨보자.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// 클라이언트와 같은 제 3의 오브젝트가 UserDao 오브젝트가 사용할 ConnectionMaker 오브젝트를 전달해주도록 만듬
public UserDao(ConnectionMaker connectionMaker) {
	this.connectionMaker = connectionMaker;
}
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>public static void main(String[] args) throws ClassNotFoundException, SQLException {
	// UserDao가 사용할 ConnectionMaker 구현 클래스를 결정하고 오브젝트를 만든다.
	ConnectionMaker connectionMaker = new DConnectionMaker();

	// 1. UserDao 생성
	// 2. 사용할 ConnectionMaker 타입의 오브젝트 제공
	//    결국 두 오브젝트 사이의 의존관계 설정 효과
	UserDao dao = new UserDao(connectionMaker);
}
</code></pre>
</div>

<p>인터페이스를 사용하므로써 상속을 통한 확장 방법보다 더 깔끔하고 유연한 방법으로 UserDao와 ConnectionMaker 클래스들을 분리하고, 서로 영향을 주지 않으면서도 필요에 따라 자유롭게 확장할 수 있는 구조가 됐다.</p>

<blockquote>
  <p>클래스 사이의 관계와 오브젝트 사이의 관계의 차이를 구분할 수 있어야 한다. <strong>클래스 사이의 관계는 코드에 다른 클래스 이름이 나타나기 때문에 만들어지는 것</strong>이다. 하지만 <strong>오브젝트 사이의 관계</strong>는 모델링 시에는 없었던, 그래서 <strong>코드에는 보이지 않던 관계가 런타임시 오브젝트로 만들어진 후에 생성</strong>되는 것이다.</p>
</blockquote>

<h2 id="section-5">원칙과 패턴</h2>
<p>지금까지 초난감 DAO 코드를 개선해온 결과를 객체지향 기술의 여러 가지 이론을 통해 설명하려고 한다.</p>

<h3 id="section-6">개방 폐쇄 원칙</h3>
<p>개방 폐쇄 원칙(OCP, Open-Closed Principle)은 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙 중의 하나다. 이 원칙을 간단히 정의하자면 <strong>클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야한다</strong>라고 할 수 있다.</p>

<p>인터페이스를 통해 수정한 UserDao는 개방폐쇄 원칙을 잘 따르고 있다. 인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 활짝 개방되어 있다. 반면 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄되어 있다.</p>

<p>인터페이스를 사용해 확장 기능을 정의한 대부분의 API는 바로 이 개방 폐쇄 원칙을 따른다고 볼 수 있다.</p>

<p>즉, 변경없이 확장 가능한 모습으로 설계하자!</p>

<h3 id="section-7">높은 응집도와 낮은 결합도</h3>
<p>응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 것이다. 또한, 응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수도 있다. 즉 <strong>변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다</strong>고 말할 수 있다. 만약 모듈의 일부분에만 변경이 일어나도 된다면, 모듈 전체에서 어떤 부분이 바뀌어야 하는지 파악해야 하고, 또 그 변경으로 인해 바뀌지 않는 부분에는 다른 영향을 미치지는 않는지 확인해야 하는 이중의 부담이 생긴다.</p>

<p>낮은 결합도는 높은 응집도보다 더 민감한 원칙이다. 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다. 느슨한 연결은 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것이다(eg. 인터페이스). <strong>결합도가 낮아지면 변화에 대응하는 속도가 높아지고, 구성이 깔끔해진다.</strong></p>

<p>즉, 관심사가 같은 애들끼리 묶고(=높은 응집도) 관심사가 다른 애들하고는 간접적으로 연결(=낮은 결합도)시키자!</p>

<h3 id="section-8">전략 패턴</h3>
<p>전략 패턴은 자신의 기능맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다. 개방 폐쇄 원칙의 실현에도 가장 잘 들어맞는 패턴이라고 볼 수 있다.</p>

<p>UserDao는 전략 패턴의 컨텍스트에 해당한다. 컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한, DB 연결 방식아라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고, 이를 구현한 클래스, 즉 전략을 바꿔가면서 사용할 수 있게 분리했다.</p>

<p>전략 패턴은 클라이언트의 필요성에 대해서도 잘 설명하고 있다. 컨텍스트(UserDao)를 사용하는 클라이언트(UserDaoTest)는 컨텍스트가 사용할 전략(ConnectionMaker를 구현한 클래스)을 컨택스트의 생성자 등을 통해 제공해주는 게 일반적이다.</p>

<p>이렇게 보면 UserDao는 개방 폐쇄 원칙을 잘 따르고 있으며, 응집력이 높고 결합도는 낮으며, 전략 패턴을 적용했음을 알 수 있다. 지금은 이렇게 말하기엔 낯간지러울 만큼 간단한 코드지만, 이 구조가 점점 복잡하게 발전해나가면 이 원칙과 패턴의 장점이 확연하게 드러날 것이다.</p>

<h1 id="ioc">제어의 역전(IoC)</h1>

<h1 id="ioc-1">스프링의 IoC</h1>

<h1 id="section-9">싱글톤 레지스트리와 오브젝트 스코프</h1>

<h1 id="di">의존관계 주입(DI)</h1>

<h1 id="xml--">XML을 이용한 설정</h1>


      <footer class="site-footer">
  <span class="site-footer-owner"><a href="http://localhost:4000">Spring Framework Study</a> is maintained by <a href="https://2narabbit.github.io">2narabbit</a>.</span>
  <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/pietromenna/jekyll-cayman-theme">Cayman theme</a> by <a href="http://github.com/jasonlong">Jason Long</a>.</span>
</footer>


    </section>

  </body>
</html>
